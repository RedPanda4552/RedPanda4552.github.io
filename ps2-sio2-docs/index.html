<!DOCTYPE html>
<html lang="en">
    <head>
        <title>PlayStation 2 SIO2 Docs</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta property="og:title" content="PlayStation 2 SIO2 Docs">
        <meta property="og:description" content="This document outlines the Serial Input Output 2 bus and the memory cards and controllers it is used to communicate with">
        <meta property="og:url" content="https://redpanda4552.github.io/ps2-sio2-docs/index.html">
        <meta property="og:image" content="https://redpanda4552.github.io/!assets/favicon.png">
        <meta name="theme-color" content="#006FC5">

        <link rel="stylesheet" href="/!css/main.css">
        <link rel="stylesheet" href="/!css/skeleton.css">
        <link rel="stylesheet" href="/!css/normalize.css">

        <link rel="icon" type="image/png" href="/!assets/favicon.png">
    </head>
    <body>
        <div class="container">
            <div class="row">
                <div class="twelve columns">
                    <h1>PlayStation 2: Serial Input Output 2, Memory Cards, Controllers, Multitaps, and More!</h1>
                    <p>
                        This document outlines the Serial Input Output 2 bus and the memory cards, controllers, multitaps, and anything else developers tried to cram into those ports.
                    </p>
                    <p>
                        This document is a work in progress. Updates will continue to roll in as I have time to work on it.
                    </p>
                    <h5>Sources and Methods for Information Gathering</h5>
                    <ul>
                        <li>Read from another documented source (sources listed at the end of this document).</li>
                        <li>Derived from reverse engineering IOP modules and EE libraries.</li>
                        <li>Observed from PS2 homebrew tests compiled with PS2SDK, and ran on a SCPH-39001 model PS2.</li>
                        <li>Observed from the effects of emulation code changes on retail PS2 games.</li>
                    </ul>
                    <h5>A Note About Updated Libraries and Modules</h5>
                    <p>
                        Another important detail to note is later in the PS2's lifecycle, Sony introduced libmc2 and libpad2 which, in my opinion, complicate things substantially more.
                        The IOP modules used in tandem with these EE libraries are much more tightly integrated with DBCMAN. This decision makes sense for device management purposes;
                        this way all the various I/O devices, controlled by SIO2 or not, can be handled as devices out of a single module.
                    </p>
                    <p>
                        However, for the sake of reverse engineering, I find it substantially harder to work with.
                        Most information revolves around the original libmc, libpad, and the IOP modules they talk to.
                        Information about the updated EE libraries and IOP modules will be sparse, if not missing from this document, for the foreseeable future.
                    </p>
                </div>
            </div>
            <div class="row">
                <div class="twelve columns">
                    <h2>Table of Contents</h2>
                    <ul>
                        <li>
                            <a href="#terms">Words, Terms, Slang, Lingo</a>
                        </li>
                        <li>
                            <a href="#sio2">Serial Input Output 2 (SIO2)</a>
                        </li>
                        <li>
                            <a href="#memcard">PlayStation 2 Memory Cards</a>
                        </li>
                        <li>
                            <a href="#pad">PlayStation 2 Controllers</a>
                        </li>
                        <li>
                            <a href="#multitap">PlayStation 2 Multitaps</a>
                        </li>
                        <li>
                            <a href="#src">Sources</a>
                        </li>
                    </ul>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="twelve columns">
                    <h2 id="terms">Words, Terms, Slang, Lingo</h2>
                    <p>Throughout this document there will be a number of words, terms, slang, lingo, whatever you want to call it. Here's my attempt at defining some of these.</p>
                    <table>
                        <thead>
                            <th>Word</th>
                            <th>Meaning</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>SIO2</td>
                                <td>"Serial Input Output 2"</td>
                            </tr>
                            <tr>
                                <td>memcard</td>
                                <td>"memory card"</td>
                            </tr>
                            <tr>
                                <td>fs</td>
                                <td>"filesystem", "file system", "file-system"</td>
                            </tr>
                            <tr>
                                <td>ECC</td>
                                <td>"Error Correction Code"</td>
                            </tr>
                            <tr>
                                <td>FAT</td>
                                <td>"File Allocation Table"</td>
                            </tr>
                            <tr>
                                <td>pad</td>
                                <td>"controller", "game pad", "joy pad"</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="twelve columns">
                    <h2 id="sio2">Serial Input Output 2 (SIO2)</h2>
                    <ul>
                        <li>
                            <a href="#sio2regmap">SIO2 Register Memory Map</a>
                        </li>
                        <li>
                            <a href="#sio2regs">SIO2 Registers</a>
                        </li>
                        <li>
                            <a href="#sio2-register-emulation">SIO2 Register Emulation Considerations</a>
                        </li>
                    </ul>
                    <h3 id="sio2regmap">SIO2 Register Memory Map</h3>
                    <table class="shrink-last">
                        <thead>
                            <th>Name</th>
                            <th>Address</th>
                            <th>Data Type</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>SEND3</td>
                                <td>0x1F808200 - 0x1F80823F</td>
                                <td>int[16]</td>
                            </tr>
                            <tr>
                                <td>SEND1/SEND2</td>
                                <td>0x1F808240 - 0x1F80825F</td>
                                <td>int[8]</td>
                            </tr>
                            <tr>
                                <td>FIFO_IN</td>
                                <td>0x1F808260</td>
                                <td>char</td>
                            </tr>
                            <tr>
                                <td>FIFO_OUT</td>
                                <td>0x1F808264</td>
                                <td>char</td>
                            </tr>
                            <tr>
                                <td>CTRL</td>
                                <td>0x1F808268</td>
                                <td>int</td>
                            </tr>
                            <tr>
                                <td>RECV1</td>
                                <td>0x1F80826C</td>
                                <td>int</td>
                            </tr>
                            <tr>
                                <td>RECV2</td>
                                <td>0x1F808270</td>
                                <td>int</td>
                            </tr>
                            <tr>
                                <td>RECV3</td>
                                <td>0x1F808274</td>
                                <td>int</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="sio2regs">SIO2 Registers</h3>
                    <ul>
                        <li>
                            <a href="#send3">SEND3</a>
                        </li>
                        <li>
                            <a href="#send1send2">SEND1/SEND2</a>
                        </li>
                        <li>
                            <a href="#fifoin">FIFO_IN</a>
                        </li>
                        <li>
                            <a href="#fifoout">FIFO_OUT</a>
                        </li>
                        <li>
                            <a href="#ctrl">CTRL</a>
                        </li>
                        <li>
                            <a href="#recv1">RECV1</a>
                        </li>
                        <li>
                            <a href="#recv2">RECV2</a>
                        </li>
                        <li>
                            <a href="#recv3">RECV3</a>
                        </li>
                    </ul>
                    <h4 id="send3">SEND3</h4>
                    <p>
                        Used internally by SIO2MAN to track how many commands it is sending, to which physical ports, and how long they are.
                    </p>
                    <p>
                        This register is an array of 16 ints. For each int:
                    </p>
                    <table class="shrink-last">
                        <thead>
                            <th>Bit</th>
                            <th>Name</th>
                            <th>Description</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>0</td>
                                <td>Port</td>
                                <td>Which physical port on the front of the console is being targeted. When unset, this maps to "1" on the front of the console, when set this maps to "2" on the front of the console.</td>
                            </tr>
                            <tr>
                                <td>1-7</td>
                                <td>Unused</td>
                                <td>No known purpose.</td>
                            </tr>
                            <tr>
                                <td>8-17</td>
                                <td>Fake Length</td>
                                <td>
                                    <p>Specifies a "fake" length of the command in bytes. Some games will still report the full length of the command here, others will report only a part of the command's proper length here.</p>
                                    <p>It is not absolute, but it seems like a general rule here is that, of games which do not report the real length here, they tend to specify a "length that actually matters", in other words of the bytes in the command, which ones actually are conveying information rather than just padding out the length (e.g. an attempt to set a sector, normally a 9 byte command, may be shortened to 7 here). Or, in the case of a read or write command, a game may only specify the length of the header/footer bytes, with the actual data being read or written subtracted from the length (e.g. a read command for 128 bytes of data, normally a total command length of 134, may have a length of 6 here, and if we combine that with the previous rule to trim useless bytes, we might even end up with 3 here for a read).</p>
                                </td>
                            </tr>
                            <tr>
                                <td>18-27</td>
                                <td>Actual Length</td>
                                <td>Specifies the actual length of the command in bytes. This will always contain the full length of the command, in bytes.</td>
                            </tr>
                            <tr>
                                <td>28-31</td>
                                <td>Unused</td>
                                <td>No known purpose.</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4 id="send1send2">SEND1/SEND2</h4>
                    <p>
                        A mystery pair of registers whose exact purpose is unknown. Though these registers both exist interweaved in the same memory address, IOP modules reference these both as separate registers.
                        Bit 2 (zero indexed) can be used to tell if it is SEND1 (unset) or SEND2 (set).
                    </p>
                    <h4 id="fifoin">FIFO_IN</h4>
                    <p>
                        Register where IOP modules can write commands to be sent to peripherals. Though named as FIFO, this is not a queue but a single register to place one byte of data at a time.
                        This register is 32 bits wide, but only the LSB is ever written.
                    </p>
                    <p>
                        It is unclear what the underlying electrical mechanism is for this, but possible that the ISTAT or CTRL register play some role in controlling when the data written here is transmitted to a peripheral.
                    </p>
                    <h4 id="fifoout">FIFO_OUT</h4>
                    <p>
                        Register where IOP modules can read data received from peripherals. Though named as FIFO, this is not a queue but a single register to place one byte of data at a time.
                        This register is 32 bits wide, but only the LSB is ever read.
                    </p>
                    <p>
                        It is unclear what the underlying electrical mechanism is for this, but it is possible that the ISTAT or CTRL register play some role in controlling when the IOP module is notified of the data put here by a peripheral.
                    </p>
                    <h4 id="ctrl">CTRL</h4>
                    <p>
                        Control register for SIO2. Known bits include 0 for starting command transfers, and 2 and 3 which reset SIO2. Most variants of SIO2MAN seem to set this register to 0x000003BC on resets.
                    </p>
                    <h4 id="recv1">RECV1</h4>
                    <p>
                        Written by unknown means, this register is updated to reflect the status of the peripheral being communicated with. This register is never written to from IOP space.
                        IOP modules read this register, typically after FIFO_IN writes are finished, and before FIFO_OUT reads begin.
                    </p>
                    <p>
                        Classically believed to tell us strictly if any one device is plugged in. But after provoking a PS2 with some homebrew, blasting it with various pad commands, plugging and unplugging controllers all the while,
                        some more nuanced behavior can be observed. While this list is not exhaustive of every possible open/disconnect pairing, I do believe it encapsulates all of the possible <i>outcomes</i>.
                    </p>
                    <ul>
                        <li>
                            <a href="#recv1-tests">RECV1 Test Results (Pads Only)</a>
                        </li>
                        <li>
                            <a href="#recv1-mtap">Multitap Differences</a>
                        </li>
                    </ul>
                    <h5 id="recv1-tests">RECV1 Test Results (Pads Only)</h5>
                    <p>
                        The following general rules seem to explain well enough the meanings of the values found in RECV1:
                    </p>
                    <ul>
                        <li>
                            The first two nibbles from the right are always zero, except for undefined behavior/uninitialized memory.
                        </li>
                        <li>
                            The third nibble from the right will indicate how many devices have been opened.
                        </li>
                        <li>
                            The fourth nibble from the right will say if an opened device is missing or not.
                            <ul>
                                <li><code>1</code> = no opened device is missing</li>
                                <li><code>D</code> = at least one device which was previously opened is now missing</li>
                            </ul>
                        </li>
                        <li>
                            The fifth nibble from the right will provide a bitmask of which opened devices are missing, if any.
                            <ul>
                                <li><code>1</code> = port 1 opened but missing</li>
                                <li><code>2</code> = port 2 opened but missing</li>
                                <li><code>3</code> = ports 1 and 2 opened but missing</li>
                            </ul>
                        </li>
                    </ul>
                    <p>
                        These scenarios may need some additional runs - these were carried out with the PS2SDK pad module and its behavior seems flaky at best. I encountered multiple scenarios where polls were returning inputs from the wrong pad,
                        or the printf statements in my code simply would not run, and there would be no indication of where or why the code just stopped running.
                    </p>
                    <table class="shrink-last">
                        <thead>
                            <th>Scenario</th>
                            <th>RECV1</th>
                            <th>Comments</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>No controllers plugged in at boot.</li>
                                    </ul>
                                </td>
                                <td><code>0x001EB7C8</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>Pad 1 is plugged in at boot.</li>
                                        <li>Pad 1 is opened.</li>
                                    </ul>
                                </td>
                                <td><code>0x00001100</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 is plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 is opened.
                                        </li>
                                        <li>
                                            Pad 1 is disconnected.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x0001D100</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 is plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 2 is opened.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x001EB7C8</code></td>
                                <td>
                                    Inconsistent. Initial test yielded the above, further attempts yielded <code>0x00001100</code>, but the test ELF (continuing to inspect the SIO2 transfer) would TLB miss shortly after. Retail games will always try to initialize pad 1 alone, or both pads together, so I consider this test result fun but meaningless.
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 2 is plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 2 is opened.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x00001100</code></td>
                                <td>Impractical to try to use port 2 without port 1, but technically nothing wrong with it.</td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 2 is plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 2 is opened.
                                        </li>
                                        <li>
                                            Pad 2 is disconnected.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x0001D100</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 2 is plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 is opened.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x001EB7C8</code></td>
                                <td>Curiously, this run does not seem to TLB miss my PS2, unlike the test where I plugged in Pad 1 and opened Pad 2. A key difference is my test ELF freezes in place on this scenario, as opposed to the other which continued to try and check the pad.</td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 and Pad 2 are plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 is opened.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x00001100</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 and Pad 2 are plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 is opened.
                                        </li>
                                        <li>
                                            Pad 1 is disconnected.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x0001D100</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 and Pad 2 are plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 and Pad 2 are opened.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x00001200</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 and Pad 2 are plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 and Pad 2 are opened.
                                        </li>
                                        <li>
                                            Pad 1 is disconnected.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x0001D200</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 and Pad 2 are plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 and Pad 2 are opened.
                                        </li>
                                        <li>
                                            Pad 2 is disconnected.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x0002D200</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            Pad 1 and Pad 2 are plugged in at boot.
                                        </li>
                                        <li>
                                            Pad 1 and Pad 2 are opened.
                                        </li>
                                        <li>
                                            Pad 1 and Pad 2 are disconnected.
                                        </li>
                                    </ul>
                                </td>
                                <td><code>0x0003D200</code></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                    <h5 id="recv1-mtap">Multitap Differences</h5>
                    <p>
                        RECV1 behaves a bit differently with multitaps. Normally for pads, bits 16 and 17 being set would indicate if port 0 and port 1 were empty, respectively. Instead, if either multitap is missing (or both),
                        only bit 16 is set, regardless of port. MTAPMAN only evaluates bit 16, not 17, when trying to determine if the device is not present. 
                    </p>
                    <h4 id="recv2">RECV2</h4>
                    <p>
                        Written by unknown means, purpose unknown. IOP modules read this register, typically after FIFO_IN writes are finished, and before FIFO_OUT reads begin.
                    </p>
                    <h4 id="recv3">RECV3</h4>
                    <p>
                        Written by unknown means, the upper short seems to be the size of the data received. IOP modules read this register, typically after FIFO_IN writes are finished, and before FIFO_OUT reads begin.
                    </p>
                    <h3 id="sio2-register-emulation">SIO2 Register Emulation Considerations</h3>
                    <p>Some registers have some special considerations that can be made in the context of emulation.</p>
                    <ul>
                        <li>
                            <a href="#sio2-fifo-shortcuts">FIFO_IN and FIFO_OUT Shortcuts</a>
                        </li>
                    </ul>
                    <h4 id="sio2-fifo-shortcuts">FIFO_IN and FIFO_OUT Shortcuts</h4>
                    <p>
                        For the purposes of emulation, a lot of the timing constraints found on SIO0's equivalent registers do not apply to FIFO_IN and FIFO_OUT in SIO2;
                        the PS1 depended on tight timing due to SIO0 being tightly woven into the kernel.
                        However, these registers can be reliably emulated without such considerations because the IOP modules do almost all state management in high level software.
                    </p>
                    <p>
                        The primary mechanism by which commands flow in to SIO2 and data flows out are writes to FIFO_IN, and reads from FIFO_OUT. These memory writes and reads are all issued by IOP modules.
                        There is no special mechanism which needs emulated in order to support this behavior, besides having a place to store values for these registers.
                    </p>
                    <p>
                        When the IOP writes to FIFO_IN, an implementation can instantly transmit that to the emulated peripheral, take the emulated peripheral's data byte, and store that to FIFO_OUT.
                        There is no need to wait for other register statuses; the IOP module which issued the write to FIFO_IN will subsequently issue a read on FIFO_OUT.
                    </p>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="twelve columns">
                    <h2 id="memcard">PlayStation 2 Memory Cards</h2>
                    <ul>
                        <li>
                            <a href="#mcfs">Memcard Filesystem</a>
                        </li>
                        <li>
                            <a href="#cmds">Memcard Commands</a>
                        </li>
                        <li>
                            <a href="#copy-protected">Games Which Copy Protect Their Save Files</a>
                        </li>
                        <li>
                            <a href="#capacity-compat">Games Which Have Issues With Higher Capacity Memcards</a>
                        </li>
                        <li>
                            <a href="#defective-games">Games With Dangerous/Defective Memcard Code</a>
                        </li>
                    </ul>
                    <h3 id="mcfs">Memcard Filesystem</h3>
                    <ul>
                        <li>
                            <a href="#structs">Data Structures</a>
                        </li>
                        <li>
                            <a href="#superblock">Superblock</a>
                        </li>
                        <li>
                            <a href="#fat">File Allocation Table (FAT)</a>
                        </li>
                        <li>
                            <a href="#dir">Directory Tree</a>
                        </li>
                        <li>
                            <a href="#format">Formatting</a>
                        </li>
                    </ul>
                    <h4 id="structs">Data Structures</h4>
                    <p>The PS2 memcard filesystem can be broken down into a few different data structures or organizational units.</p>
                    <ul>
                        <li>
                            <a href="#page">Page</a>
                        </li>
                        <li>
                            <a href="#cluster">Cluster</a>
                        </li>
                        <li>
                            <a href="#eraseblock">Erase Block</a>
                        </li>
                    </ul>
                    <h5 id="page">Page</h5>
                    <p>A group of data bytes, followed by ECC bytes. The data bytes can be either 512 or 1024 bytes long; this is the Page Length attribute specified in the superblock. OEM memcards from Sony will always use 512 bytes. Though the 1024 byte size is supported, there are no known cases (yet) of a real memcard actually using this.</p>
                    <p>The ECC bytes following the data bytes are 16 bytes long if the page length is 512, or 32 bytes long if the page length is 1024. In either case, every 128 bytes of data corresponds to 3 bytes of ECC data.</p>
                    <table>
                        <thead>
                            <th>Physical Size</th>
                            <th>Data Bytes Used</th>
                            <th>Data Bytes Total</th>
                            <th>ECC Bytes Used</th>
                            <th>ECC Bytes Total</th>
                            <th>Data Byte to ECC Byte Mapping</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>528</td>
                                <td>512</td>
                                <td>512</td>
                                <td>12</td>
                                <td>16</td>
                                <td>128 bytes data = 3 bytes ECC</td>
                            </tr>
                            <tr>
                                <td>1056</td>
                                <td>1024</td>
                                <td>1024</td>
                                <td>24</td>
                                <td>32</td>
                                <td>128 bytes data = 3 bytes ECC</td>
                            </tr>
                        </tbody>
                    </table>
                    <h5 id="cluster">Cluster</h5>
                    <p>A group of pages. Clusters can be 1 or 2 pages long; this is the Pages Per Cluster attribute specified in the superblock. OEM memcards from Sony will always use Pages Per Cluster = 2. If the Page Length attribute of the superblock is 1024, then Pages Per Cluster must be 1.</p>
                    <table>
                        <thead>
                            <th>Page Length</th>
                            <th>Pages Per Cluster = 1</th>
                            <th>Pages Per Cluster = 2</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>512</td>
                                <td>Supported</td>
                                <td>Supported</td>
                            </tr>
                            <tr>
                                <td>1024</td>
                                <td>Supported</td>
                                <td>NOT Supported</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Clusters are primarily used in the FAT and for navigation. Presumably, it requires a smaller FAT this way (at least for OEM memcards where 1 cluster = 2 pages = 1024 data bytes); a single FAT entry points to two pages worth of data, rather than having a FAT entry for every page. The disadvantage is that small, loose files can lead to wasted space. A single FAT entry points to one cluster, so whatever file belongs to that FAT entry ends up consuming both pages even if it is only 256 bytes long, leading to 768 unused data bytes.</p>
                    <p>Directories do remedy this partially by leveraging each individual page as a directory entry. When populating a directory tree for a memory card, the FAT is traversed and this tells you what clusters and in what order to traverse them to populate the directory tree. When a cluster is visited, it is simply expected that each page can be an individual directory entry, and so both pages at that cluster position are checked individually.</p>
                    <p>Contrast with files, a single file is given a single cluster position, and there is no indication or expectation that two files can live on different pages in the same cluster, so any unused space across the entire cluster is lost until the file is deleted and the cluster's pages can be reallocated to a new file or directory entry.</p>
                    <h5 id="eraseblock">Erase Block</h5>
                    <p>A group of pages. Erase blocks default to 16 pages long; this is the Pages Per Erase Block attribute specified in the superblock. 16 is the maximum number of pages supported per erase block. It is unclear whether this number can be reduced.</p>
                    <p>Erase blocks are the units of which a memcard can be erased. Because memcards are flash memory, bits can only be flipped one direction. In all known cases, the "default" position of a bit is 1, and bits can only be flipped to 0. To flip back to 1, an entire erase block must be "cleared" to 1's. As such, prior to any write operation, a page's entire erase block must be erased first.</p>
                    <h4 id="superblock">Superblock</h4>
                    <p>The superblock is the "brain" of the memcard. This page stores information describing the size and health of the memcard.</p>
                    <p>
                        <i>Quotes found in the below table are to express that something is a string value. The values themselves do not contain quote characters.</i>
                    </p>
                    <table class="shrink-last">
                        <thead>
                            <th>Offset</th>
                            <th>Name</th>
                            <th>Data Type</th>
                            <th>Default</th>
                            <th>Description</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>0x00</td>
                                <td>Format String</td>
                                <td>char[28]</td>
                                <td>"Sony PS2 Memory Card Format "</td>
                                <td>Constant ASCII string. Evaluated when checking if a memcard is formatted. Will be present on a formatted memcard, missing otherwise. This string ends with a space, and is not null terminated!</td>
                            </tr>
                            <tr>
                                <td>0x1C</td>
                                <td>Version</td>
                                <td>char[12]</td>
                                <td>"1.x.0.0"</td>
                                <td>Version string. Version "1.2.x.y" has full support for the Bad Block List, older versions have limited or none. This string is null terminated (unused bytes are null terminators). It's currently unclear if this version number is provisioned by the console or the card.</td>
                            </tr>
                            <tr>
                                <td>0x28</td>
                                <td>Page Length</td>
                                <td>short</td>
                                <td>512</td>
                                <td>Size in bytes of a memcard page. Can be either 512 or 1024. No known cases of a real memcard using 1024.</td>
                            </tr>
                            <tr>
                                <td>0x2A</td>
                                <td>Pages Per Cluster</td>
                                <td>short</td>
                                <td>2</td>
                                <td>Number of pages in a memcard cluster. Can be 1 or 2 if page length is 512, must be 1 if page length is 1024.</td>
                            </tr>
                            <tr>
                                <td>0x2C</td>
                                <td>Pages Per Block</td>
                                <td>short</td>
                                <td>16</td>
                                <td>Number of pages in a memcard erase block. </td>
                            </tr>
                            <tr>
                                <td>0x2E</td>
                                <td>Unknown</td>
                                <td>short</td>
                                <td>0xff00</td>
                                <td>Doesn't appear to be used, purpose unknown.</td>
                            </tr>
                            <tr>
                                <td>0x30</td>
                                <td>Clusters On Card</td>
                                <td>int</td>
                                <td>8192</td>
                                <td>Size of the memcard in clusters.</td>
                            </tr>
                            <tr>
                                <td>0x34</td>
                                <td>Allocation Offset</td>
                                <td>int</td>
                                <td>0x41</td>
                                <td>Offset of the first "allocatable" cluster. Offset is relative to the beginning of the memcard. Cluster values in the FAT and directory entries are then relative to this cluster. "Allocatable" means a cluster which is not reserved for a special purpose (e.g. FAT or backup) and can be used to store files and make directory entries.</td>
                            </tr>
                            <tr>
                                <td>0x38</td>
                                <td>Allocation End</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x3C</td>
                                <td>Root Directory Cluster</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x40</td>
                                <td>Backup Block 1</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x44</td>
                                <td>Backup Block 2</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x48</td>
                                <td>Unknown</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x4C</td>
                                <td>Unknown</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x50</td>
                                <td>Indirect FAT Cluster List</td>
                                <td>int[32]</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0xD0</td>
                                <td>Bad Block List</td>
                                <td>int[32]</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x150</td>
                                <td>Card Type</td>
                                <td>char</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x151</td>
                                <td>Card Flags</td>
                                <td>char</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x152</td>
                                <td>Unknown</td>
                                <td>short</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x154</td>
                                <td>ClUster Size</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x158</td>
                                <td>FAT Entries Per Cluster</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x15C</td>
                                <td>Clusters Per Block</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x160</td>
                                <td>Card Form</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x164</td>
                                <td>Root Directory Cluster 2</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x168</td>
                                <td>Unknown</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x16C</td>
                                <td>Unknown</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>0x170</td>
                                <td>Max Allocatable Clusters</td>
                                <td>int</td>
                                <td></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                    <h4 id="fat">File Allocation Table (FAT)</h4>
                    <h4 id="dir">Directory Tree</h4>
                    <h4 id="format">Formatting</h4>
                    <h3 id="cmds">Memcard Commands</h3>
                    <p>Memcards accept a number of commands, encoded as streams of bytes sent over the SIO2 bus.</p>
                    <ul>
                        <li>
                            <a href="#probe">0x11 - Probe</a>
                        </li>
                        <li>
                            <a href="#unkwritedel">0x12 - Unknown (Write/Delete End)</a>
                        </li>
                        <li>
                            <a href="#setpageerase">0x21 - Set Page (Erase)</a>
                        </li>
                        <li>
                            <a href="#setpagewrite">0x22 - Set Page (Write)</a>
                        </li>
                        <li>
                            <a href="#setpageread">0x23 -  Set Page (Read)</a>
                        </li>
                        <li>
                            <a href="#getspecs">0x26 - Get Specs</a>
                        </li>
                        <li>
                            <a href="#setterminator">0x27 - Set Terminator</a>
                        </li>
                        <li>
                            <a href="#getterminator">0x28 - Get Terminator</a>
                        </li>
                        <li>
                            <a href="#writedata">0x42 - Write Data</a>
                        </li>
                        <li>
                            <a href="#readdata">0x43 - Read Data</a>
                        </li>
                        <li>
                            <a href="#ps1read">0x52 - PS1 Read</a>
                        </li>
                        <li>
                            <a href="#ps1state">0x53 - PS1 State</a>
                        </li>
                        <li>
                            <a href="#ps1write">0x57 - PS1 Write</a>
                        </li>
                        <li>
                            <a href="#ps1pocketstationprobe">0x58 - PS1 Pocketstation Probe</a>
                        </li>
                        <li>
                            <a href="#readwriteend">0x81 - Read/Write End</a>
                        </li>
                        <li>
                            <a href="#eraseblock">0x82 - Erase Block</a>
                        </li>
                        <li>
                            <a href="#unkboot">0xBF - Unknown Boot</a>
                        </li>
                        <li>
                            <a href="#authenticationxor">0xF0 - Authentication (Multiple XOR)</a>
                        </li>
                        <li>
                            <a href="#authenticationf3">0xF3 - Authentication (F3)</a>
                        </li>
                        <li>
                            <a href="#authenticationf7">0xF7 - Authentication (F7)</a>
                        </li>
                    </ul>
                    <h4 id="probe">0x11 - Probe</h4>
                    <p>A basic heartbeat command to test if a memcard is present in a port. Only the last two response bytes matter, they should be 0x2B and the memcard's current terminator byte.</p>
                    <table>
                        <thead>
                            <th>Byte (zero indexed)</th>
                            <th>0</th>
                            <th>1</th>
                            <th>2</th>
                            <th>3</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Command</td>
                                <td>0x81</td>
                                <td>0x11</td>
                                <td>0x00</td>
                                <td>0x00</td>
                            </tr>
                            <tr>
                                <td>Response</td>
                                <td>0x00</td>
                                <td>0x00</td>
                                <td>0x2B</td>
                                <td>Terminator</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4 id="unkwritedel">0x12 - Unknown (Write/Delete End)</h4>
                    <p>A command which games send to memcards after writes or erases. Its purpose is currently unknown. A theory is that this is some kind of acknowledge signal; sceMcSync is used on the EE to check if a memcard function has completed or stall until it does. Perhaps sceMcSync is waiting for this command to be processed?</p>
                    <p>This command conventionally has a length of 4 bytes. Only the last two response bytes matter, they should be 0x2B and the memcard's current terminator byte. The 3rd byte seems to switch between 0x00 and 0x3F, but this appears to be arbitrary to the command completing. Additionally a value may appear at command byte 6, beyond the length specified in the SEND3 register when this command is used, but this too appears arbitrary to completion.</p>
                    <table>
                        <thead>
                            <th>Byte (zero indexed)</th>
                            <th>0</th>
                            <th>1</th>
                            <th>2</th>
                            <th>3</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Command</td>
                                <td>0x81</td>
                                <td>0x12</td>
                                <td>0x00</td>
                                <td>0x00 or 0x3F</td>
                            </tr>
                            <tr>
                                <td>Response</td>
                                <td>0x00</td>
                                <td>0x00</td>
                                <td>0x2B</td>
                                <td>Terminator</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4 id="setpageerase">0x21 - Set Page (Erase)</h4>
                    <h4 id="setpagewrite">0x22 - Set Page (Write)</h4>
                    <h4 id="setpageread">0x23 - Set Page (Read)</h4>
                    <h4 id="getspecs">0x26 - Get Specs</h4>
                    <h4 id="setterminator">0x27 - Set Terminator</h4>
                    <h4 id="getterminator">0x28 - Get Terminator</h4>
                    <h4 id="writedata">0x42 - Write Data</h4>
                    <h4 id="readdata">0x43 - Read Data</h4>
                    <h4 id="ps1read">0x52 - PS1 Read</h4>
                    <h4 id="ps1state">0x53 - PS1 State</h4>
                    <h4 id="ps1write">0x57 - PS1 Write</h4>
                    <h4 id="ps1pocketstationprobe">0x58 - PS1 Pocketstation Probe</h4>
                    <h4 id="readwriteend">0x81 - Read/Write End</h4>
                    <h4 id="eraseblock">0x82 - Erase Block</h4>
                    <h4 id="unkboot">0xBF - Unknown Boot</h4>
                    <h4 id="authenticationxor">0xF0 - Authentication (Multiple XOR)</h4>
                    <h4 id="authenticationf3">0xF3 - Authentication (F3)</h4>
                    <h4 id="authenticationf7">0xF7 - Authentication (F7)</h4>
                    <h3 id="copy-protected">Games Which Copy Protect Their Save Files</h3>
                    <p>
                        One of the new features introduced to PS2 memory cards is copy protection. Quite simply, a save file can be flagged as protected, and if so, the BIOS will refuse to copy it to another memory card.
                        The implementation of the copy protection is done entirely in the PS2 BIOS; other software can simply choose not to implement it, and completely bypass it. LLE emulators are an exception to this,
                        as they will continue to execute the native BIOS code which includes copy protection.
                    </p>
                    <table>
                        <thead>
                            <th>Title</th>
                            <th>Serials/Regions Known</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>PS2 Network Configuration (BWNETCONF)</td>
                                <td>NTSC-J</td>
                            </tr>
                            <tr>
                                <td>Monster Hunter</td>
                                <td>SLUS-20896, SLES-52707, SLPM-65495</td>
                            </tr>
                            <tr>
                                <td>Monster Hunter 2 dos</td>
                                <td>SLPM-66280</td>
                            </tr>
                            <tr>
                                <td>Sims 2 Castaway</td>
                                <td>SLES-54903</td>
                            </tr>
                            <tr>
                                <td>Sims 2 Pets</td>
                                <td>SLES-54347</td>
                            </tr>
                            <tr>
                                <td>Star Ocean: Till the End of Time (Battle Trophies)</td>
                                <td>SLUS-20488, SLUS-20891</td>
                            </tr>
                            <tr>
                                <td>Timesplitters (Game Settings)</td>
                                <td>SLES-50078</td>
                            </tr>
                            <tr>
                                <td>Timesplitters 2 (Game Settings)</td>
                                <td>SLES-50877</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="capacity-compat">Games Which Have Issues With Higher Capacity Memcards</h3>
                    <p>
                        Some games are incompatible with higher capacity cards. While theoretically there is a 2 GB ceiling on memcard capacity,
                        most third party memcards were at most 64 MB. If test results can be produced for higher capacities, they will be listed.
                        Otherwise, only sizes 64 MB and under will be included.
                    </p>
                    <table>
                        <thead>
                            <th>Title</th>
                            <th>Known Good Capacities</th>
                            <th>Known Bad Capacities</th>
                            <th>Untested</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Sonic Riders</td>
                                <td>8 MB, 16 MB, 32 MB</td>
                                <td>64 MB</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>The Punisher (SLUS-20864)</td>
                                <td>8 MB</td>
                                <td>32 MB</td>
                                <td>16 MB, 64 MB</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="defective-games">Games With Defective/Dangerous Memcard Code</h3>
                    <p>A number of games have been found over the years to contain behavior which is dangerous to memcards.</p>
                    <ul>
                        <li>
                            <a href="#jak-x">Jak X Combat Racing</a>
                        </li>
                        <li>
                            <a href="#soul-calibur-3">Soul Calibur III</a>
                        </li>
                        <li>
                            <a href="#playstation-underground">PlayStation Underground Holiday 2004 Demo Disc</a>
                        </li>
                    </ul>
                    <h4 id="jak-x">Jak X Combat Racing</h4>
                    <p>
                        Jak X Combat Racing has a bug where the game will soft lock while saving. After waiting a decent amount of time, it does seem like it becomes safe to reset the PS2, and that save data is actually being fully committed to the memcard.
                        However, according to user reports this does not always seem to be the case, so it is best to try and work around this bug whenever possible. This bug affects all regions (NTSC/PAL alike) and occurs on all PS2 models.
                        There may be a higher likelihood to encounter this issue on a slim PS2, however it is not exclusive to slims nor can this be conclusively verified.
                    </p>
                    <p>
                        The bug is best worked around by ejecting the memory card prior to any save operations. Let the game detect that the card is missing, then reinsert it and let the game save.
                        Be sure not to ever eject a memory card during a save or load operation.
                    </p>
                    <p>
                        Naughty Dog allegedly patched this issue in the Greated Hits release of the game. For PAL regions, this would be the "Platinum" version, if one exists.
                    </p>
                    <h4 id="soul-calibur-3">Soul Calibur 3</h4>
                    <p>Soul Calibur 3 has an issue where any data written to a memcard prior to its own save file being placed on the card must not be modified. Any kind of change to the size of a file written to the card before Soul Calibur 3's save file was added, will result in Soul Calibur 3 no longer recognizing its own save file and instead saying it is corrupt. This issue is known to affect all versions (NTSC/PAL alike).</p>
                    <p>This issue is best worked around by plain and simply giving this game its own memory card.</p>
                    <p>It is highly likely the developers chose to do some kind of nonstandard practice revolving around the FAT on the memcard. However, it is not exactly clear what this would entail; the most likely explanation is that they are doing something bizarre to the FAT. That raises additional questions however, as the FAT is only accessible from the IOP module, suggesting modifications may have been made to MCMAN. The standard memory card functions are invoked from the EE and behave extremely similarly to stdio, using file descriptors and paths rather than page manipulation.</p>
                    <h4 id="playstation-underground">PlayStation Underground Holiday 2004 Demo Disc</h4>
                    <p>The PlayStation Underground Holiday 2004 Demo Disc ended up being a nightmare for many gamers alike and a liability for all who took part in its release. It was directly responsible for many save files being irreversibly destroyed.</p>
                    <p>While simply booting the demo disc is fine, as are most games on the disc, the disc contains a demo for Viewtiful Joe 2. This demo has code in it which issues multiple memory card format commands, as well as multiple memory card write commands. The formats will wipe out the FAT and return the card to a "fresh" state. The write commands will then overwrite seemingly random areas of the card with garbage. It is worth noting most of the writes end up being out of bounds, and/or misaligned. All data on the memcard is lost at this point.</p>
                    <p>Running the format function on a memory card is a very deliberate action for a game to take. As is writing data to a memory card. To suggest that this is truly a bug, and not malicious action taken by a rogue developer seems to be a gross mischaracterization of the amount of deliberance and effort taken to ensure this release made it on to this demo disc. Even during development, having the boot sequence of your game run the memory card format function multiple times is not something you would do. Having the boot sequence of your game run memory card writes to random, misaligned addresses, is not something you would do. Having your game run memory card writes targeted to addresses in the first place, is not something you can do from the SDK. You need to modify an IOP module to make that happen.</p>
                    <p>Either they had a really, really, REALLY bad time with some unfortunate undefined behavior that no one noticed before this demo made it out the door. Or, someone made sure that this demo had a little bit of a different startup sequence in it, and managed to make sure no one found out about it until the first poor sap ran this demo.</p>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="twelve columns">
                    <h2 id="pad">PlayStation 2 Controllers</h2>
                    <ul>
                        <li>
                            <a href="#pad-commands">Pad Commands</a>
                        </li>
                        <li>
                            <a href="#pad-digital-buttons">Digital Button Mapping</a>
                        </li>
                        <li>
                            <a href="#pad-identity-handshake">Pad Identification/Handshake Commands and Responses</a>
                        </li>
                        <li>
                            <a href="#pad-ds2-vibration-motors">DualShock 2 Vibration Motors</a>
                        </li>
                    </ul>
                    <h3 id="pad-commands">Pad Commands</h3>
                    <ul>
                        <li>
                            <a href="#pad-command-mystery">Mystery</a>
                        </li>
                        <li>
                            <a href="#pad-command-button-query">Button Query</a>
                        </li>
                        <li>
                            <a href="#pad-command-poll">Poll</a>
                        </li>
                    </ul>
                    <h4 id="pad-command-mystery">Mystery</h4>
                    <h4 id="pad-command-button-query">Button Query</h4>
                    <h4 id="pad-command-poll">Poll</h4>
                    <h3 id="pad-digital-buttons">Digital Button Mapping</h3>
                    <p>All controllers will use two bytes in positions 3 and 4 (zero indexed) of their poll commands to store all of the digital button states. The table below shows which bits correspond to which buttons.</p>
                    <p>Byte 3:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Bit 7 (MSB)</th>
                                <th>Bit 6</th>
                                <th>Bit 5</th>
                                <th>Bit 4</th>
                                <th>Bit 3</th>
                                <th>Bit 2</th>
                                <th>Bit 1</th>
                                <th>Bit 0 (LSB)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Left</td>
                                <td>Down</td>
                                <td>Right</td>
                                <td>Up</td>
                                <td>Start</td>
                                <td>R3</td>
                                <td>L3</td>
                                <td>Select</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Byte 4:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Bit 7 (MSB)</th>
                                <th>Bit 6</th>
                                <th>Bit 5</th>
                                <th>Bit 4</th>
                                <th>Bit 3</th>
                                <th>Bit 2</th>
                                <th>Bit 1</th>
                                <th>Bit 0 (LSB)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Square</td>
                                <td>Cross</td>
                                <td>Circle</td>
                                <td>Triangle</td>
                                <td>R1</td>
                                <td>L1</td>
                                <td>R2</td>
                                <td>L2</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="pad-identity-handshake">Pad Identification/Handshake Commands and Responses</h3>
                    <p>Most pads, with the exception of the PS1 digital pad, can be issued configuration commands by the PS2 to change their operating mode and identify their capabilities to the PS2.</p>
                    <p>While there are some specific commands which are situational and will have specific details explained, many of these commands are static, predictable responses simply aimed to tell the PS2 what type of pad it is or how many of some thing the pad has.</p>
                    <h4>PS1 Digital Pad</h4>
                    <p>The most basic pad to ever grace the Playstation ecosystem. 14 face buttons, all digital on/off values with no analog sticks or pressure capability.</p>
                    <p>This controller does not support any configuration commands, including the command to enter/exit config mode itself.</p>
                    <ul>
                        <li>
                            <a href="#pad-digital-poll">Poll</a>
                        </li>
                        <li>
                            <a href="#pad-digital-config">Config</a>
                        </li>
                    </ul>
                    <h5 id="pad-digital-poll">Poll</h5>
                    <p>Get all inputs on the controller. Plain and simple. Bytes 3 and 4 are the digital mappings.</p>
                    <table>
                        <tr>
                            <th>Byte (Zero Indexed)</td>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th>Command</th>
                            <td>0x01</td>
                            <td>0x42</td>
                            <td>0x00</td>
                            <td>0x00</td>
                            <td>0x00</td>
                        </tr>
                        <tr>
                            <th>Data</th>
                            <td>0xFF</td>
                            <td>0x41</td>
                            <td>0x5A</td>
                            <td>0xFF</td>
                            <td>0xFF</td>
                        </tr>
                    </table>
                    <h5 id="pad-digital-config">Config</h5>
                    <p>
                        Ask the controller to enter or exit config mode. Digital pads may receive this command from the PS2 as it first doesn't know if the pad is truly digital only. The pad will respond that it has no idea what the command is,
                        and that tells the PS2 it is a digital pad.
                    </p>
                    <p>Interesting note - the RECV1 value on this command with only one digital pad inserted in particular is <code>0x0001D100</code>, as opposed to <code>0x00001100</code> as expected for a normal poll.</p>
                    <table>
                        <tr>
                            <th>Byte (Zero Indexed)</td>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th>Command</th>
                            <td>0x01</td>
                            <td>0x43</td>
                            <td>0x00</td>
                            <td>0x01</td>
                            <td>0x00</td>
                        </tr>
                        <tr>
                            <th>Data</th>
                            <td>0xFF</td>
                            <td>0x41</td>
                            <td>0xFF</td>
                            <td>0xFF</td>
                            <td>0xFF</td>
                        </tr>
                    </table>
                    <h3 id="pad-ds2-vibration-motors">DualShock 2 Vibration Motors</h3>
                    <ul>
                        <li>
                            <a href="#pad-ds2-motor-setup">Motor Setup</a>
                        </li>
                        <li>
                            <a href="#pad-ds2-motor-power">Motor Power</a>
                        </li>
                    </ul>
                    <h4 id="pad-ds2-motor-setup">Motor Setup</h4>
                    <p>
                        Starting with the PS1 analog pad and continuing on to the DualShock 2, controllers have two vibration motors, small and large.
                        When games poll the controller, they include up to two bytes which tell the controller how much power to send to each motor.
                        They are controlled by the 3rd and 4th (zero indexed) command bytes of a pad poll.
                    </p>
                    <p>
                        The mapping command itself is already described earlier in this document as part of the command list;
                        this section will review how that affects pad polls.
                    </p>
                    <h5 id="pad-ds2-motor-setup-normal">Normal Mapping</h5>
                    <p>
                        Take the following pad poll command for a PS1 analog pad:
                    </p>
                    <table>
                        <tr>
                            <th>Byte (Zero Indexed)</td>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                            <td>5</td>
                            <td>6</td>
                            <td>7</td>
                            <td>8</td>
                        </tr>
                        <tr>
                            <th>Command</th>
                            <td>0x01</td>
                            <td>0x42</td>
                            <td>0x00</td>
                            <td>0x01</td>
                            <td>0xFF</td>
                            <td>0x00</td>
                            <td>0x00</td>
                            <td>0x00</td>
                            <td>0x00</td>
                        </tr>
                        <tr>
                            <th>Data</th>
                            <td>0xFF</td>
                            <td>0x41</td>
                            <td>0x5A</td>
                            <td>0xFF</td>
                            <td>0xFF</td>
                            <td>0x7F</td>
                            <td>0x7F</td>
                            <td>0x7F</td>
                            <td>0x7F</td>
                        </tr>
                    </table>
                    <p>
                        Under normal circumstances, the small motor is controlled by the 3rd byte, and large motor by the 4th. This particular example would turn on the small motor with power level 0x01,
                        and turn on the large motor with power level 0xFF. However, the pad protocol supports remapping these.
                    </p>
                    <p>
                        The vibration config command's 3rd and 4th (zero indexed) bytes correspond to small and large motor.
                        Whichever values are supplied in these positions of the console's command then determines which byte of a pad poll that motor will get its power level from.
                    </p>
                    <p>
                        The normal thing to do would be for the 3rd byte to be 0x00, and the 4th byte to be 0x01.
                        In other words, the small motor will look at the first vibration value (the 3rd byte of the poll), and the large motor will look at the second vibration value (the 4th byte of the poll).
                    </p>
                    <table>
                        <caption>Normal Vibration Motor Mapping</caption>
                        <tr>
                            <th>Byte (Zero Indexed)</td>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th>Command</th>
                            <td>0x01</td>
                            <td>0x42</td>
                            <td>0x00</td>
                            <td>0xFF</td>
                            <td>0x01</td>
                        </tr>
                        <tr>
                            <th>Data</th>
                            <td>0xFF</td>
                            <td>0x41</td>
                            <td>0x5A</td>
                            <td>0xFF</td>
                            <td>0xFF</td>
                        </tr>
                    </table>
                    <p>
                        It is uncommon, but some games such as FFX do rearrange the motors. Take the example of a vibration config command where the 3rd byte is 0x01, and the 4th byte is 0x00;
                        this would set small motor to the second vibration value (the 4th byte of the poll), and large motor to the first vibration value (the 3rd byte of the poll).
                        In such a case, if you then wanted to turn on both motors to full power, your pad poll would now look like:
                    </p>
                    <table>
                        <caption>Reversed Vibration Motor Mapping</caption>
                        <tr>
                            <th>Byte (Zero Indexed)</td>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th>Command</th>
                            <td>0x01</td>
                            <td>0x42</td>
                            <td>0x00</td>
                            <td>0xFF</td>
                            <td>0x01</td>
                        </tr>
                        <tr>
                            <th>Data</th>
                            <td>0xFF</td>
                            <td>0x41</td>
                            <td>0x5A</td>
                            <td>0xFF</td>
                            <td>0xFF</td>
                        </tr>
                    </table>
                    <p>
                        While reversing the vibration bytes is in-spec, the utility of this is questionable.
                        A good analogy would be to think of a pipeline between vibration commands being sent as parameters using SDK functions on the EE, and the actual vibration motors electrically kicking on.
                        Think of everything between them as a black box for now.
                    </p>
                    <p>
                        You could describe this as a set of parallel lines. Left line for small motor, right line for large motor.
                        Suppose the mapping is reversed like above, effectively all that has changed is that instead of a set of parallel lines, you now have a double-helix like the shape of DNA.
                        The lines are now curved over each other twice, but both still arrive at the same destination with the same values as before.
                        The game twists the lines over to the wrong side, and then the controller untwists them back to the right side again.
                        Another way to phrase it would be that the game says to the controller "I am going to send them backwards", and the controller replies "Okay, I will read them backwards".
                    </p>
                    <p>
                        The most likely guess for why this is a feature at all is in the event that a developer only wants to use one of the two motors, they can accomplish that by disabling one of them in the mapping.
                        This is done by passing 0xFF in to the respective motor in the vibration config command.
                    </p>
                    <h4 id="pad-ds2-motor-power">Motor Power</h4>
                    <p>Power delivery to the motors is handled directly in software. Both the small motor and large motor are set using an unsigned char value.</p>
                    <p>The small motor is binary and only considers the LSB of the unsigned char. In other words, if it is an odd number, the small motor will turn on. If an even number, it will turn off.</p>
                    <p>The large motor considers the full range of the unsigned char and will power on accordingly. However, due to either a hardware cutoff, the motor's physical weight being to high, or some combination of both, the motor will only start actually spinning at a certain power level.</p>
                    <p>On my DS2, the first perceivable large motor vibration was felt at 0x40, but it was barely able to work, and simply shaking the controller a little was enough for the weight of the motor to overcome the power delivered to it.</p>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="twelve columns">
                    <h2 id="multitap">PlayStation 2 Multitaps</h2>
                    <p>The multitap is a peripheral which plugs in to both a memory card and pad port at the same time. It expands each of these ports into four slots. Two multitaps can be plugged in for a total of eight slots.</p>
                    <p>Internally, each of the two ports gets four slots assigned to it and these map predictably to the letters shown on the multitap. Slot A = 0, Slot B = 1, Slot C = 2, Slot D = 3.</p>
                    <p>
                        Pad and memcard functions almost always take port and slot parameters. The port refers to the two physical port on the front of the PS2, and slot refers to the four multitap slots.
                        If the software has no intent to use the multitaps, the slot is always 0.
                    </p>
                    <p>Multitaps are effectively switches or routing devices. It is assumed that, after being plugged in, if they do not receive any commands to change the routing target, they default to just forward all commands to slot A.</p>
                    <ul>
                        <li>
                            <a href="#mtap-fmcb">FreeMCBoot Compatibility</a>
                        </li>
                        <li>
                            <a href="#mtap-bizarre-games">Games With Bizarre Multitap Behavior</a>
                        </li>
                    </ul>
                    <h3 id="mtap-fmcb">FreeMCBoot Compatibility</h3>
                    <p>
                        FreeMCBoot memcards can only be successfully used in multitap slot A. Inserting a FreeMCBoot memcard into any other slot will have no effect and the system will boot normally.
                    </p>
                    <h3 id="mtap-bizarre-games">Games With Bizarre Multitap Behavior</h3>
                    <p>
                        There are some general conventions that, while not enforced or really even recommended, were just generally "the thing to do". With multitaps, one of those is making a sort of
                        abstraction layer where the game can reasonably work out which controller should map to which player in the game. Even here there's probably plenty of different ways developers
                        could and would implement this in their games. But some games took a bit of an unusual approach.
                    </p>
                    <ul>
                        <li>
                            <a href="#mtap-digimon">Digimon Rumble Arena 2</a>
                        </li>
                        <li>
                            <a href="#mtap-downhill">Downhill Domination</a>
                        </li>
                        <li>
                            <a href="#mtap-wwe-pain">WWE SmackDown! Here Comes the Pain</a>
                        </li>
                    </ul>
                    <h4 id="mtap-digimon">Digimon Rumble Arena 2</h4>
                    <p>
                        Digimon Rumble Arena 2 chose to simplify its controller handling by requiring you to use your multitap in port 2. The game will always expect to find a pad in port 1 with no multitap.
                        Perhaps they thought "people will always want a pad in their first port, it's the second one which may or may not be used; so lets only check for multitaps there". Or, they got lazy and
                        only wanted to run multitap checks against port 2. The latter seems a little more likely - rather than run some kind of abstraction layer where "the Xth pad to connect takes the Xth player slot in-game",
                        the multitap slots are literally hard coded to the player slots in-game.
                    </p>
                    <p>
                        If you have a multitap in port 1, slot A continues to work in the multitap's "default" state, none of the other slots work. Port 2 still works normally.
                    </p>
                    <p>
                        If you have a multitap in port 2, port 1 = player 1, slot 2-A = player 2, slot 2-B = player 3, slot 2-C = player 4, slot 2-D is not useable. That's right. 2-A, 2-B, 2-C get hard coded to the in-game players,
                        and you are not allowed to scramble that at all.
                    </p>
                    <p>
                        What's worse, the manual tells you to put your multitap into port 1! The one that doesn't work!
                    </p>
                    <h4 id="mtap-downhill">Downhill Domination</h4>
                    <p>
                        Downhill Domination is incredibly literal minded with its multitap implementation. The game only accepts a multitap in port 1. Attempting to use a multitap in port 2 results in the same "default behavior"
                        as any other game - slot 2-A is treated the same as literal port 2, the rest of the slots are dead.
                    </p>
                    <p>
                        When a multitap is inserted to port 1, the game no longer considers port 2 valid. All controllers must be connected through the multitap. For the game to detect X controllers, the controllers must all be connected
                        sequentially. Any empty slot in the multitap results in the game thinking that slot plus any others after it are empty.
                    </p>
                    <p>
                        Even if you are trying to play two player, the multitap gets in the way! Using slot 1-A and port 2 together, the game will not detect the second controller.
                    </p>
                    <h4 id="mtap-wwe-pain">WWE SmackDown! Here Comes the Pain</h4>
                    <p>
                        WWE SmackDown! Here Comes the Pain requires multitap slots to be filled sequentially. Port 1 must be multitapped first. If port 2 is multitapped without multitapping port 1, slot 2-A is treated the same as
                        literal port 2, the rest of the slots are dead.
                    </p>
                    <p>
                        With a port 1 multitap, port 2 is ignored until all slots on the multitap are occupied, at which point it becomes available for player 5. For the game to detect X controllers, the controllers must all be
                        connected sequentially. Any empty slot in the multitap results in the game thinking that slot plus any others after it are empty.
                    </p>
                    <p>
                        With both ports multitapped, slots must still be occupied sequentially; port 1's multitap filled first, then the rest in the port 2 multitap.
                    </p>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="twelve columns">
                    <h2 id="src">Sources</h2>
                    <ul>
                        <li>
                            <a href="#ross">Ross Ridge's "PlayStation 2 Memory Card File System" Document</a>
                        </li>
                        <li>
                            <a href="#ps2tek">PSI's "ps2tek" Document</a>
                        </li>
                        <li>
                            <a href="#faqs">Campaign4Games' File Corruption Document for Soul Calibur III on GameFAQs</a>
                        </li>
                    </ul>
                    <h3 id="ross">Ross Ridge's "PlayStation 2 Memory Card File System" Document</h3>
                    <p>Provides information on the entire PS2 memcard filesystem.</p>
                    <h4>Links</h4>
                    <ul>
                        <li>
                            <a href="http://www.csclub.uwaterloo.ca:11068/mymc/ps2mcfs.html">
                                Original document
                            </a>
                        </li>
                        <li>
                            <a href="https://web.archive.org/web/20220501172129/http://www.csclub.uwaterloo.ca:11068/mymc/ps2mcfs.html">
                                A snapshot on the Wayback Machine (2022-05-01)
                            </a>
                        </li>
                    </ul>
                    <h3 id="ps2tek">PSI's "ps2tek" Document</h3>
                    <p>Absolutely critical in making heads or tails of the PS2's IOP modules for SIO2, memcards, and pads.</p>
                    <h4>Links</h4>
                    <ul>
                        <li>
                            <a href="https://psi-rockin.github.io/ps2tek/">Original document</a>
                        </li>
                        <li>
                            <a href="https://web.archive.org/web/20220903190800/https://psi-rockin.github.io/ps2tek/">A snapshot on the Wayback Machine (2022-09-03)</a>
                        </li>
                    </ul>
                    <h3 id="faqs">Campaign4Games' File Corruption Document for Soul Calibur III on GameFAQs</h3>
                    <p>Provides a full user-level breakdown of Soul Calibur III's issues with save files.</p>
                    <h4>Links</h4>
                    <ul>
                        <li>
                            <a href="https://gamefaqs.gamespot.com/ps2/927089-soulcalibur-iii/faqs/40424">Original document</a>
                        </li>
                        <li>
                            <a href="https://web.archive.org/web/20230427210917/https://gamefaqs.gamespot.com/ps2/927089-soulcalibur-iii/faqs/40424">A snapshot on the Wayback Machine (2023-04-27)</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </body>
</html>
